# Одна из пяти задач Яндекс Контеста
Здесь вы сможете ознакомиться с задачей Яндекс Контеста 2022 года для отбора на стажировку на позицию бэкенд-разработчика.
## A. Хитрый шифр
| | |
|---- |:---- |
|Ограничение памяти | 2 секунды
|Ограничение памяти | 512Mb
|Ввод               | стандартный ввод или input.txt
|Вывод              | стандартный вывод или output.txt

Известная компания Тындекс в очередной раз проводит набор стажёров.
Заботясь о персональных данных соискателей, компания придумала хитрый алгоритм шифрования:
-	Подсчитывается количество различных символов в ФИО (регистр важен, А и а — разные символы).
-	Берётся сумма цифр в дне и месяце рождения, умноженная на 64.
-	Для первой (по позиции в слове) буквы фамилии определяется её номер в алфавите (в 1-индексации), умноженный на 256 (регистр буквы не важен).
-	Полученные числа суммируются.
-	Результат переводится в 16-чную систему счисления (в верхнем регистре).
-	У результата сохраняются только 3 младших разряда (если значимых разрядов меньше, то шифр дополняется до 3-х разрядов ведущими нулями).

Ваша задача — помочь вычислить для каждого кандидата его шифр.

## Формат ввода
В первой строке вводится число N(1≤N≤10000) — количество кандидатов и шифров.
Далее следует N строк в формате CSV (f<sub>j</sub>,i<sub>j</sub>,o<sub>j</sub>,d<sub>j</sub>,m<sub>j</sub>,y<sub>j</sub>) — информация о кандидатах:
-	Фамилия f<sub>j</sub>, имя i<sub>j</sub> и отчество o<sub>j</sub>(1≤∣∣f<sub>j</sub>∣∣,∣∣i<sub>j</sub>∣∣,∣∣o<sub>j</sub>∣∣≤15) — строки, состоящие из латинских букв верхнего и нижнего регистра;
-	день рождения d<sub>j</sub>, месяц рождения m<sub>j</sub> и год рождения y<sub>j</sub> — целые числа, задающие корректную дату в промежутке от 1 января 1950 года до 31 декабря 2021 года.
## Формат вывода
В единственной строке выведите N строк k<sub>1</sub>, k<sub>2</sub>, …, k<sub>N</sub>, где k<sub>j</sub> — шифр j-го кандидата (в верхнем регистре). Кандидаты нумеруются с 1 до N в порядке ввода.

## Пример
|Ввод|
|:--------------------------------------- |
|2                                        |
|Volozh,Arcady,Yurievich,11,2,1964        |
|Segalovich,Ilya,Valentinovich,13,9,1964  |

|Вывод|
|:---------------|
|710 64F         |

## Примечания
Рассмотрим тестовый пример.

Первый кандидат — Volozh,Arcady,Yurievich,11,2,1964:
-	Различные символы в ФИО: V, o, l, z, h, A, r, c, a, d, y, Y, u, i, e, v - всего их 16.
-	Сумма цифр в дне и месяце рождения равна 1+1+2= 4.
-	Номер в алфавите первой буквы фамилии V равен 22.
-	Итоговое значение шифра равно 16+4⋅64+22⋅256= 5904.
-	В 16-ричной системе счисления это число представимо как 1710.
-	Нас интересуют только 3 последние разряда, поэтому остаётся 710.

Второй кандидат — Segalovich,Ilya,Valentinovich,13,9,1964:
-	Различные символы в ФИО: S, e, g, a, l, o, v, i, c, h, I, y, V, n, t - всего их 15.
-	Сумма цифр в дне и месяце рождения равна 1+3+9= 13.
-	Номер в алфавите первой буквы фамилии S равен 19.
-	Итоговое значение шифра равно 15+13⋅64+19⋅256= 5711.
-	В 16-ричной системе счисления это число представимо как 164F.
-	Нас интересуют только 3 последние разряда, поэтому остаётся 64F.

Мой пример решения(исключительно для ознакомления):
```
N = int(input())

csv = []
alphabet = '0abcdefghijklmnopqrstuvwxyz'

for i in range(N):
    f = list(map(str, input().split()))
    csv += f

for i in csv:
    full_name_date = i.split(',')
    full_name = full_name_date[0] + full_name_date[1] + full_name_date[2]
    len_full_name = len(set([char for char in full_name]))
    
    d_m = full_name_date[3] + full_name_date[4]
    sum_d_m = sum([int(char) for char in d_m])
    
    index_first_char = alphabet.find(full_name[0].lower())
    
    result_decimal = len_full_name + sum_d_m * 64 + index_first_char * 256
    result_hexadecimal = hex(result_decimal)[2:].upper()
    
    if len(result_hexadecimal) >= 3:
        print(result_hexadecimal[-3:], end=' ')
    elif len(result_hexadecimal) < 3:
        while len(result_hexadecimal) < 3:
            result_hexadecimal = '0' + result_hexadecimal
        print(result_hexadecimal[-3:], end=' ')

```
